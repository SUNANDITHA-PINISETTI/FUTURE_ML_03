# -*- coding: utf-8 -*-
"""customer_chatbot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_-CxKRjUK1aFrXJW_KRmqAiASvKzZ3ez
"""

!pip install flask chatterbot chatterbot_corpus

from chatterbot import ChatBot
from chatterbot.trainers import ChatterBotCorpusTrainer

# Initialize chatbot
chatbot = ChatBot('SmartSupportBot')

# Train the chatbot
trainer = ChatterBotCorpusTrainer(chatbot)
trainer.train("chatterbot.corpus.english")

# Function to chat with the bot
def get_response(user_input):
    response = chatbot.get_response(user_input)
    return str(response)

# Test the chatbot
print(get_response("Hello!"))

!pip install flask pyngrok

from flask import Flask, request, jsonify
from chatterbot import ChatBot
from chatterbot.trainers import ChatterBotCorpusTrainer
from pyngrok import ngrok

app = Flask(__name__)
chatbot = ChatBot('SmartSupportBot')
trainer = ChatterBotCorpusTrainer(chatbot)
trainer.train("chatterbot.corpus.english")

@app.route('/chat', methods=['POST'])
def chat():
    user_input = request.json.get('message')
    response = chatbot.get_response(user_input)
    return jsonify({'response': str(response)})

# Expose the server using ngrok
public_url = ngrok.connect(5000)
print("Public URL:", public_url)

app.run()

!ngrok authtoken YOUR_AUTHTOKEN

from pyngrok import ngrok

public_url = ngrok.connect(5000)
print("Public URL:", public_url)

!ngrok authtoken YOUR_AUTHTOKEN

!pip install --upgrade pyngrok

!ngrok authtoken YOUR_AUTHTOKEN

from google.colab import files
uploaded = files.upload()

import pandas as pd

df = pd.read_csv("customer_support_tickets[1].csv")
df.head()

df.head()

import nltk
from nltk.chat.util import Chat, reflections
nltk.download('punkt')

pairs = []

for index, row in df.iterrows():
    subject = row['Ticket Subject']
    description = row['Ticket Description']
    resolution = row['Resolution'] if pd.notnull(row['Resolution']) else "Our team is working on it."

    if pd.notnull(subject) and pd.notnull(description):
        # Add a pattern-response pair
        question = subject.lower()
        answer = f"Problem: {description}\nResolution: {resolution}"
        pairs.append([rf"(.*){question}(.*)", [answer]])

# Fallback response
pairs.append([r"(.*)", ["Sorry, I didn't catch that. Could you try again?"]])

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

def prepare_bot(df):
    questions = df['Ticket Subject'].fillna('').tolist()
    answers = (df['Ticket Description'].fillna('') + "\nResolution: " + df['Resolution'].fillna("No resolution provided")).tolist()

    vectorizer = TfidfVectorizer()
    X = vectorizer.fit_transform(questions)

    return vectorizer, X, answers

def get_response(user_input, vectorizer, X, answers):
    user_vec = vectorizer.transform([user_input])
    sim = cosine_similarity(user_vec, X).flatten()
    if max(sim) < 0.3:
        return "Sorry, I didn't catch that. Could you try again?"
    idx = sim.argmax()
    return answers[idx]

import random
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Predefined responses for different query types
response_variants = {
    "refund": [
        "You can request a refund through our website under 'Order History'.",
        "Refunds are processed within 3-5 business days. Let me know if you need assistance.",
        "You may initiate a refund request here: [Refund Portal Link]."
    ],
    "order status": [
        "Your order is on its way! You can track it using the link provided in your email.",
        "Your order should arrive soon. Check your account for live tracking details.",
        "We've shipped your order! You’ll receive updates via email shortly."
    ],
    "technical issue": [
        "Please try restarting the application and clearing your cache. Let me know if that helps!",
        "It sounds frustrating! Have you tried reinstalling the software?",
        "Our support team is available 24/7—feel free to reach out if the issue persists."
    ]
}

# Function to process each query independently
def get_predefined_response(user_input):
    vectorizer = TfidfVectorizer()
    X = vectorizer.fit_transform(response_variants.keys())

    user_vec = vectorizer.transform([user_input])
    sim = cosine_similarity(user_vec, X).flatten()

    if max(sim) < 0.3:
        return "Sorry, I didn't catch that. Could you try again?"

    topic = list(response_variants.keys())[sim.argmax()]
    return random.choice(response_variants[topic])

# Interactive chatbot loop
print("Chatbot: Hello! How can I assist you today?")
while True:
    user_query = input("You: ")
    if user_query.lower() in ["exit", "quit", "bye"]:
        print("Chatbot: Goodbye! Have a great day.")
        break
    response = get_predefined_response(user_query.lower())
    print(f"Chatbot: {response}")